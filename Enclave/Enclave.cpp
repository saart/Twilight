#include "Enclave_t.h" // Headers for trusted part (autogenerated by edger8r)
#include <string>
#include "sgx_trts.h"
#include "sgx_tcrypto.h"
#include "sgx_tseal.h"
#include "sha3.h"
#include "AES.h"
#include <cstring>
#include <cstdlib>
#include <cstdio>
#include <iostream>
#include <sstream>
#include <string>
#include <math.h>
#include "tree.cpp"

# define ECC_PRV_KEY_SIZE 32
# define ECC_PUB_KEY_SIZE (ECC_PRV_KEY_SIZE * 2)
# define STATE_KEY_SIZE 32
# define STATE_ENCRYPTED_SIZE 16
# define BLOCK_SIZE ECC_PRV_KEY_SIZE
# define TRANSACTION_SIZE (4 + 16)
# define HASH_SIZE 32
# define DEBUG false
# define PROFILE false

using namespace std;

char* TRANSACTION_FAILED = (char*)"FAIL";

// This key is generated in the channel's initialization phase (shared symmetric key between the pair of enclaves)
uint8_t enclave_private[TRANSACTION_SIZE] = {21,82,15,151,146,163,170,236,229,18,142,72,94,107,248,22,241,230,254,84};
// This key is private, and generated at the beginning of the enclave
uint8_t state_key[STATE_KEY_SIZE] = {21,82,15,151,146,163,170,236,229,18,142,72,94,107,248,22,241,230,254,84,21,82,15,151,146,163,170,236,229,18,142,72};
sgx_status_t ret = SGX_SUCCESS;
sgx_ecc_state_handle_t ecc_state = NULL;
unsigned initialization_random = 0;


struct prevHtlc {
	uint8_t encrypted_output[TRANSACTION_SIZE];
	uint8_t encrypted_key[TRANSACTION_SIZE];
	bool is_positive;
};

struct inputs {
	uint8_t bob_dh_pub[ECC_PUB_KEY_SIZE];
	uint8_t encrypted_given_ammount[TRANSACTION_SIZE];
	uint8_t encrypted_key[TRANSACTION_SIZE];
	uint8_t prev_state[STATE_ENCRYPTED_SIZE];
	uint32_t prev_liquidity;
};

struct outputs {
	uint8_t result[TRANSACTION_SIZE];
	uint8_t key_encrypted_for_next[TRANSACTION_SIZE];
	uint8_t my_dh_pub[ECC_PUB_KEY_SIZE];
	uint8_t state[STATE_ENCRYPTED_SIZE];
};

void print_block(uint8_t* arr, size_t len){
	string const hex_chars[16] = { "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "A", "B", "C", "D", "E", "F" };
	for (size_t i = 0; i<len; i++){
		ocall_print_string(hex_chars[ ( arr[i] & 0xF0 ) >> 4 ].c_str());
		ocall_print_string(hex_chars[ ( arr[i] & 0x0F ) >> 0 ].c_str());
	}
	ocall_println_string("");
}

static inline uint64_t rdtsc(void){
    uint32_t hi, lo;
    __asm__ __volatile__("rdtsc": "=a"(lo), "=d"(hi));
    return (uint64_t(hi) << 32) | uint64_t(lo);
}

double generateNoise() {
	if (initialization_random == 0) {
		// production implementation should run it in init time, and use sgx_get_trusted_time
		ret = sgx_read_rand((unsigned char*)&initialization_random, sizeof(unsigned));
		if (ret != SGX_SUCCESS) {
			ocall_println_string("Enclave failed due to sgx_get_trusted_time problem");
			return 0;
		}
	}
	// unsinged tsc = rdtsc();  // doesn't work in SGX1
	uint64_t rdtsc;
	ocall_rdtsc(&rdtsc);
	return compute_tree_noise(rdtsc, initialization_random);
}

void xor_arrays(uint8_t* arr1, uint8_t* arr2, uint8_t* target, size_t length){
	for (int i=0; i< length; i++){
		target[i] = arr1[i] ^ arr2[i];
	}
}

bool is_valid_output(uint8_t transaction_size_chars[TRANSACTION_SIZE]) {
	for (int i = 4; i < TRANSACTION_SIZE; i++){
		if (transaction_size_chars[i] != 0) {
			if (DEBUG) ocall_print_string("First i of invalid output:");
			if (DEBUG) ocall_println_string(to_string(i).c_str());
			return false;
		}
	}
	return true;
}

bool decrypt_input(uint8_t encrypted_key[TRANSACTION_SIZE], uint8_t encrypted_output[TRANSACTION_SIZE], uint8_t* transaction_size_chars) {
	uint8_t prev_hashed_shared_secret[ECC_PRV_KEY_SIZE] = { 0 };
	xor_arrays(encrypted_key, enclave_private, prev_hashed_shared_secret, TRANSACTION_SIZE);
	xor_arrays(encrypted_output, prev_hashed_shared_secret, transaction_size_chars, TRANSACTION_SIZE);
	return true;
}

uint32_t decrypt_state(uint8_t prev_state[STATE_ENCRYPTED_SIZE]) {
	if (prev_state[0] == 0 && prev_state[1] == 0 && prev_state[2] == 0 && prev_state[3] == 0) {
		if (DEBUG) ocall_println_string("Got empty state");
		return 0;
	}
    unsigned char* res_bytes = AES().DecryptECB((unsigned char *)prev_state, STATE_ENCRYPTED_SIZE, (unsigned char *)state_key);
	uint32_t result;
	memcpy(&result, res_bytes, sizeof(uint32_t));
    if (DEBUG) ocall_print_string("Decrypted state: ");
    if (DEBUG) ocall_println_string(to_string(result).c_str());
    return result;
}

uint8_t* encrypt_state(uint32_t state) {
    unsigned int outLen = 0;
    uint8_t* res = (uint8_t*) AES().EncryptECB((unsigned char *)&state, sizeof(uint32_t), (unsigned char *)state_key, outLen);
	if (outLen != STATE_ENCRYPTED_SIZE) {
		ocall_println_string("Warning: State decrpyion size is wrong");
	}
    return res;
}

bool get_used_liquidity(uint8_t prev_state_enc[STATE_ENCRYPTED_SIZE], prevHtlc* prev_htlcs, uint8_t prev_hlcs_count, uint32_t* used_liquidity) {
	*used_liquidity = decrypt_state(prev_state_enc);

	uint8_t tx[TRANSACTION_SIZE] = { 0 };
	for (uint8_t i = 0; i < prev_hlcs_count; i++) {
		decrypt_input(prev_htlcs[i].encrypted_key, prev_htlcs[i].encrypted_output, tx);
		if (!is_valid_output(tx)) {
			ocall_println_string("Enclave failed due to invalid htlc");
			return false;
		}
		if (prev_htlcs[i].is_positive){
			*used_liquidity += *(uint32_t*)tx;
		} else {
			*used_liquidity -= *(uint32_t*)tx;
		}
		
	}
	if (DEBUG) ocall_print_string("Total pending payments:");
	if (DEBUG) ocall_println_string(to_string(*used_liquidity).c_str());
	return true;
}

bool decide_out_tx_size(inputs input, uint32_t used_liquidity, uint8_t* transaction_size_chars) {
	uint32_t transaction_size = *(uint32_t*)transaction_size_chars;

	double noise = generateNoise();
	
	if (DEBUG) ocall_print_string("Input transaction size:");
	if (DEBUG) ocall_println_string(to_string(transaction_size).c_str());

	if (!is_valid_output(transaction_size_chars)) {
		if (DEBUG) ocall_println_string("Enclave failed due to invalid input");
		memset(transaction_size_chars, 0, TRANSACTION_SIZE);
		return false;
	} else if (input.prev_liquidity - used_liquidity - noise < transaction_size) {
		if (DEBUG) ocall_println_string("Enclave failed due to prev liquidity");
		memset(transaction_size_chars, 0, TRANSACTION_SIZE);
		return false;
	}
	return true;
}

bool encrypt_output(inputs input, uint8_t* dec_out, uint8_t* enc_out, uint8_t* key_encrypted_for_next, uint8_t* my_dh_pub) {
	if (PROFILE) ocall_time_start();
	uint8_t ecc_key[ECC_PRV_KEY_SIZE] = { 0 };
	uint8_t shared_secret[ECC_PRV_KEY_SIZE] = { 0 };
	uint8_t hashed_shared_secret[HASH_SIZE] = { 0 };

	if (ecc_state == NULL){
        ret = sgx_ecc256_open_context(&ecc_state);
        if (ret != SGX_SUCCESS) {
            if (DEBUG) ocall_println_string("Enclave failed due to sgx_ecc256_open_context problem");
            return false;
        }
    }

	if (PROFILE) ocall_time_end("Encrypt initialize");
	ret = sgx_ecc256_create_key_pair((sgx_ec256_private_t*)ecc_key, (sgx_ec256_public_t*)my_dh_pub, ecc_state);
	if (ret != SGX_SUCCESS) {
		if (DEBUG) ocall_println_string("Enclave failed due to sgx_ecc256_create_key_pair problem");
		return false;
	}
	if (PROFILE) ocall_time_end("Encrypt create key");
	ret = sgx_ecc256_compute_shared_dhkey(
		(sgx_ec256_private_t*)ecc_key,
        (sgx_ec256_public_t*)input.bob_dh_pub,
        (sgx_ec256_dh_shared_t*)shared_secret, 
		ecc_state
	);
	if (ret != SGX_SUCCESS) {
		if (DEBUG) ocall_println_string("Enclave failed due to sgx_ecc256_compute_shared_dhkey problem");
		return false;
	}
	if (PROFILE) ocall_time_end("Encrypt compute shared key");
	sha3_HashBuffer(256, SHA3_FLAGS_KECCAK, shared_secret, sizeof(shared_secret), hashed_shared_secret, sizeof(hashed_shared_secret));
	if (PROFILE) ocall_time_end("Encrypt sha");
	xor_arrays(dec_out, hashed_shared_secret, enc_out, TRANSACTION_SIZE);

	xor_arrays(hashed_shared_secret, enclave_private, key_encrypted_for_next, TRANSACTION_SIZE);
	if (PROFILE) ocall_time_end("Encrypt end");
	return true;
}

void ecall_exec(uint8_t* raw_input, uint32_t len, uint8_t* in_prev_htlcs, uint32_t prev_htlcs_len, uint8_t* output){
    /*
	* This function returns the ammount that the relay is willing to transfer if "s" will be uncovered
	*/
	if (PROFILE) ocall_time_end("Starting");
	inputs input = {};
	outputs to_output = {};
	uint8_t transaction_size[TRANSACTION_SIZE] = { 0 };
	uint8_t output_chars[TRANSACTION_SIZE] = { 0 };
	uint8_t key_encrypted_for_next[TRANSACTION_SIZE] = { 0 };
	uint8_t my_dh_pub[ECC_PUB_KEY_SIZE] = { 0 };
	uint8_t prev_htlcs_count = prev_htlcs_len / sizeof(prevHtlc);
	uint32_t used_liquidity = 0;
	bool is_succeed = true;

	memcpy(&input, raw_input, sizeof(inputs));
	if (PROFILE) ocall_time_end("Initialization");

	is_succeed &= decrypt_input(input.encrypted_key, input.encrypted_given_ammount, transaction_size);
	if (PROFILE) ocall_time_end("decrypt");
	is_succeed &= get_used_liquidity(input.prev_state, (prevHtlc*)in_prev_htlcs, prev_htlcs_count, &used_liquidity);
	if (PROFILE) ocall_time_end("get_used");
	is_succeed &= decide_out_tx_size(input, used_liquidity, transaction_size);
	if (PROFILE) ocall_time_end("decide");
	is_succeed &= encrypt_output(input, transaction_size, output_chars, key_encrypted_for_next, my_dh_pub);
	if (PROFILE) ocall_time_end("encrypt");

	if (is_succeed) {
		memcpy(to_output.result, output_chars, TRANSACTION_SIZE);
		memcpy(to_output.key_encrypted_for_next, &key_encrypted_for_next, sizeof(key_encrypted_for_next));
		memcpy(to_output.my_dh_pub, &my_dh_pub, ECC_PUB_KEY_SIZE);
		memcpy(to_output.state, encrypt_state(used_liquidity), STATE_ENCRYPTED_SIZE);
		memcpy(output, &to_output, sizeof(outputs));
	} else {
	    if (DEBUG) ocall_println_string("Enclave failed on input:");
	    if (DEBUG) ocall_print_string("bob_dh_pub:");
	    if (DEBUG) print_block(input.bob_dh_pub, ECC_PUB_KEY_SIZE);
	    if (DEBUG) ocall_print_string("encrypted_given_ammount:");
	    if (DEBUG) print_block(input.encrypted_given_ammount, TRANSACTION_SIZE);
	    if (DEBUG) ocall_print_string("encrypted_key:");
	    if (DEBUG) print_block(input.encrypted_key, TRANSACTION_SIZE);
	    if (DEBUG) ocall_print_string("prev_state:");
	    if (DEBUG) print_block(input.prev_state, STATE_ENCRYPTED_SIZE);
		memset(output, 0, sizeof(outputs));
	}
	
	if (PROFILE) ocall_time_end("Finalization");
}
